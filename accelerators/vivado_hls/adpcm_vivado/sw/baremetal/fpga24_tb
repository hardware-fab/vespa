/* Copyright (c) 2011-2023 Columbia University, System Level Design Group */
/* SPDX-License-Identifier: Apache-2.0 */

#include <stdio.h>
#ifndef __riscv
#include <stdlib.h>
#endif

#include "esp_accelerator.h"
#include "esp_probe.h"
#include "fixed_point.h"

#include "accelerators.h"
#include <monitors.h>

//TEST CONFIGURATIONS
//#define DFADD_ACTIVE 0
#define BENCH_N dfmul_n
//#define POS_0 11
//#define POS_1 12
#define ACC_POS 11
#define MEM_TILE_ID 4
//#define BENCH_ID 0x300

//---------------------Timer Definitions-----------------------------
#define BASE_ADDRESS 0x60000300
#define TIMER_LO 0xB4
#define TIMER_HI 0xB8
#define DOMAIN_0 ((16 + 0)*4 + 128)
#define DOMAIN_1 ((16 + 1)*4 + 128)
#define DOMAIN_2 ((16 + 2)*4 + 128)
#define DOMAIN_3 ((16 + 3)*4 + 128)

static long unsigned custom_gettime_nano()
{
	volatile unsigned long timer_reg_lo, timer_reg_hi;
	volatile uint32_t * timer_lo_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_LO);
	volatile uint32_t * timer_hi_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_HI);
	timer_reg_lo = *timer_lo_ptr;
	timer_reg_hi = *timer_hi_ptr;
	return (long unsigned) ((*timer_lo_ptr | (long unsigned)(*timer_hi_ptr)<<32)*CLOCK_PERIOD);
}

static void print_time(long unsigned value)
{
	uint32_t nano = value%1000;
	uint32_t micro = (value%1000000)/1000;
	uint32_t milli = (value%1000000000)/1000000;
	uint32_t sec = (value%1000000000000)/1000000000;
	printf("Original Value = %lu : %u s - %u ms - %u us - %u ns", value, sec, milli, micro, nano);
}

static void print_time_us(long unsigned value)
{
	uint32_t decimal = value%1000;
	uint32_t integer = (value)/1000;
	printf("%u,%03u", integer, decimal);
}

static void wait_micro(long unsigned waiting_time)
{
	long unsigned start, end;
	start = custom_gettime_nano();
	end = 0;
	while(end < start + waiting_time*1000)
		end = custom_gettime_nano();
	return;
}

//--------------Global Variables--------------------------
//Accelerators size variables
static unsigned in_words_adj[N_ACC_TILES];
static unsigned out_words_adj[N_ACC_TILES];
static unsigned in_len[N_ACC_TILES];
static unsigned out_len[N_ACC_TILES];
static unsigned in_size[N_ACC_TILES];
static unsigned out_size[N_ACC_TILES];
static unsigned out_offset[N_ACC_TILES];
static unsigned mem_size[N_ACC_TILES];

//Devices info
struct esp_device *acc_ptr[N_ACC_TILES];

//Accelerators I/O
unsigned **ptable[N_ACC_TILES];
uint8_t *mem[N_ACC_TILES];
uint8_t *gold[N_ACC_TILES];
unsigned errors = 0;

//Execution results
unsigned samples_counter = 0;
//unsigned packets_data[N_SAMPLES];
unsigned packets_data_2[N_SAMPLES];
uint8_t noc_frequency_data[N_SAMPLES];
uint8_t acc_frequency_data[N_SAMPLES];
uint8_t tg_frequency_data[N_SAMPLES];
unsigned time_data_debug[N_SAMPLES];

//--------------Functions Declaration------------------
int init_devs();
void config_cache();
void run_acc();

int main(int argc, char * argv[])
{
	//printf("------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------START-----------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n---------------------------------------------------------------------------------------------\n\n\n");

	//-----------------------------------Local variables------------------------------------

	//Accelerators execution
	int ready[N_ACC_TILES] = {0};
	int counter[N_ACC_TILES] = {0};
	unsigned done[N_ACC_TILES] = {0};
	int ready_all = 0;

	//Monitor variables
	unsigned backpressure_old = 0;
	esp_monitor_vals_t vals_backpressure;
	esp_monitor_vals_t vals_packets_0, vals_packets_1;
	unsigned long packets_in_NoC = 0;
	unsigned long packets_to_mem = 0, packets_from_mem = 0;
	unsigned long backpressure_total;
	int backpressure_diff;
    int toggle = 0;

	//Time variables
	double start_time, time_elapsed = 0;
	double time_acc[N_ACC_TILES] = {0};
	double window_start, window_end;
	unsigned long window_actual_time;
    static double total_time_bench[6];
	int total_counter_bench[6];

	//Frequency data
	unsigned noc_freq = 1;
	volatile uint32_t * noc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_0);
	volatile uint32_t * acc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_1);
    volatile uint32_t * cpu_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_2);
	volatile uint32_t * tg_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_3);
	uint8_t noc_freq_int = 0;
	uint8_t acc_freq_int = 0;
	uint8_t cpu_freq_int = 0;
	uint8_t tg_freq_int =  0;

	int dfadd_active = 0;

	//*cpu_freq_reg = FREQ_START;   //9 = 50MHz
	//*noc_freq_reg = noc_freq;
	//*domain2_freq_reg = FREQ_START;   //9 = 50MHz
	//*domain3_freq_reg = FREQ_START;   //9 = 50MHz

	init_devs();

    cpu_freq_int = 9;
	*cpu_freq_reg = cpu_freq_int;

	window_start = custom_gettime_nano();
	for (int m=0; m<N_TESTS; m++)
	{
		//Initialize run control variables
		//printf("Start Execution!!!\n");
		ready_all = 0;
		time_elapsed = 0;
		start_time = custom_gettime_nano();


		if((m/3)%3 == 0)
			noc_freq_int = 1; //10MHz
		else if((m/3)%3 == 1)
			noc_freq_int = 10; //55MHz
		else if((m/3)%3 == 2)
			noc_freq_int = 19; //100MHz

		if(m%3 == 0)
			acc_freq_int = 1; //10MHz
		else if(m%3 == 1)
			acc_freq_int = 5; //30MHz
		else if(m%3 == 2)
			acc_freq_int = 9; //50MHz

		if((m/9)%4 == 0)
		{
			tg_freq_int = 1; //0MHz
			dfadd_active = 0;
		}
		else if((m/9)%4 == 1)
		{
			tg_freq_int = 1; //10MHz
			dfadd_active = 1;
		}
		else if((m/9)%4 == 2)
		{
			tg_freq_int = 5; //30MHz
			dfadd_active = 1;
		}
		else if((m/9)%4 == 3)
		{
			tg_freq_int = 9; //50MHz
			dfadd_active = 1;
		}
		*noc_freq_reg = noc_freq_int;
		*acc_freq_reg = acc_freq_int;
		*tg_freq_reg = tg_freq_int;

		for(int ndev=0; ndev<N_ACC_TILES; ndev++)
		{
			counter[ndev] = 0;
			if(dfadd_active || ndev == ACC_POS)
			{
				run_acc(ndev);
				ready[ndev] = 0;
			}
			else if(!dfadd_active)
				ready[ndev] = 1;

		}

        //if (m==0)
		//{
		//	*noc_freq_reg = 19;
		//	*acc_freq_reg = 1;
		//	*cpu_freq_reg = 9;
		//}
		//else if (m==1)
		//{
		//	*noc_freq_reg = 19;
		//	*acc_freq_reg = 9;
		//	*cpu_freq_reg = 9;
		//}
		//else if (m==2)
		//{
		//	*noc_freq_reg = 1;
		//	*acc_freq_reg = 9;
		//	*cpu_freq_reg = 9;
		//}




		while(!(ready_all && time_elapsed))
		{
			//-------------------ACCELERATORS EXECUTION----------------------------
			ready_all = 1;
			for(int ndev=0; ndev<N_ACC_TILES; ndev++)
			{
				//printf("Accelerator %d: done = %d, ready = %d\n", ndev, done[ndev], ready[ndev]);
				done[ndev] = ioread32(acc_ptr[ndev], STATUS_REG);
				done[ndev] &= STATUS_MASK_DONE;
				if(!ready[ndev] && done[ndev])
				{
					done[ndev] = 0;
					iowrite32(acc_ptr[ndev], CMD_REG, 0x0);
					run_acc(ndev);
					counter[ndev]++;
					if(time_elapsed)
					{
						//printf("ndev = %d\n", ndev);
						//if(ndev == POS_0)
						//{
						//	//printf("writing in location = %d\n", m+ndev*3);
						//	total_time_bench[m] = custom_gettime_nano() - start_time;
						//	total_counter_bench[m] = counter[ndev];
						//}
						if(ndev == ACC_POS)
						{
							//printf("writing in location = %d\n", m+ndev*3);
							//total_time_bench[m+3] = custom_gettime_nano() - start_time;
							//total_counter_bench[m+3] = counter[ndev];
						}
						//time_acc[ndev] = custom_gettime_nano() - start_time;
						ready[ndev] = 1;
					}
				}
				if(!ready[ndev])
					ready_all = 0;
				//------------------DFS POLICY-------------------------------------
				window_end = custom_gettime_nano();
				if(window_end - window_start > TIME_WINDOW*1000)
				{
					unsigned long ejected_total = 0, injected_total = 0;
					unsigned long window_actual_time = window_end - window_start;
					window_start = window_end;

					esp_monitor_transit_1tile(&vals_packets_0, MEM_TILE_ID);
                    //packets_data[samples_counter] = 0;
					packets_data_2[samples_counter] = 0;
					for(int plane=0; plane <6; plane++)
					{
						//packets_data[samples_counter] += vals_packets_0.noc_injects[MEM_TILE_ID][plane];
						packets_data_2[samples_counter] += vals_packets_0.noc_ejects[MEM_TILE_ID][plane];
					}
					//printf("%d - %d - %d\n", samples_counter, packets_data[samples_counter], packets_data_2[samples_counter]);
					noc_frequency_data[samples_counter] = noc_freq_int;
					acc_frequency_data[samples_counter] = acc_freq_int;
					if(dfadd_active)
						tg_frequency_data[samples_counter] = tg_freq_int;
					else
						tg_frequency_data[samples_counter] = 0;
					time_data_debug[samples_counter] = window_actual_time;

					//if(packets_in_NoC > NOC_TH && noc_freq < FREQ_MAX)
					//{
					//	noc_freq++;
					//	*noc_freq_reg = noc_freq;
					//}
					//else if(packets_in_NoC < NOC_TL && noc_freq > FREQ_MIN)
					//{
					//	noc_freq--;
					//	*noc_freq_reg = noc_freq;
					//}
					samples_counter++;
				}
			}

			if(custom_gettime_nano() - start_time > ((unsigned long)MAX_TEST_TIME*1000000000) && !time_elapsed)
				time_elapsed = 1;

		}
	}
    printf("Execution Completed\n");
	//for(int iter=1; iter<2; iter++)
	//{
	//	int errors = print_results(iter, gold[iter], &mem[iter][out_offset[iter]], out_words_adj[iter], mem[iter]);
	//}
	//for(int k=0; k<100; k++)
	//{
	//	printf("dfsin_result[%d] = %016llx\n", k, *((uint64_t *)&mem[6][800 + k*8]));
	//}
	///* Validation */
	//errors = validate_buf(&mem[out_offset], gold);

	//for(int iter = 0; iter<N_ACC_TILES; iter++)
	//{
	//	printf("\nExecution time of the accelerator %d is: ", iter);
	//    print_time_us(time_acc[iter]/counter[iter]);
	//	printf("\n");
	//}
	for(int iter = 0; iter<6; iter++)
	{
		//printf("\nExecution time of the accelerator %d is: ", iter);
	    print_time_us(total_time_bench[iter]/(total_counter_bench[iter]*BENCH_N));
		printf("\n");
	}
	//The terminal shows only the last 1000 lines, so I divide the output in chunks of 1000 samples, and then print multiple samples in each line
	for(int sample=0; sample<PRINT_CHUNK; sample++)
	{	for(int chunk=0; chunk<samples_counter/PRINT_CHUNK+1; chunk++)
		{
			if(sample == 0 && chunk == 0)
				continue;
			printf("%d - %d - %d - %d - %d - ", chunk*PRINT_CHUNK+sample, packets_data_2[chunk*PRINT_CHUNK+sample]-packets_data_2[chunk*PRINT_CHUNK+sample-1], noc_frequency_data[chunk*PRINT_CHUNK+sample]
				   , acc_frequency_data[chunk*PRINT_CHUNK+sample], tg_frequency_data[chunk*PRINT_CHUNK+sample]);
			//printf("%d - %d - %d - ", chunk*PRINT_CHUNK+sample, packets_data[chunk*PRINT_CHUNK+sample], frequency_data[chunk*PRINT_CHUNK+sample]);
			print_time_us(time_data_debug[chunk*PRINT_CHUNK+sample]);
			printf(" - ");
		}
		printf("\n");
	}
	for(int ndev=0; ndev = N_ACC_TILES; ndev++)
	{
		aligned_free(ptable[ndev]);
		aligned_free(mem[ndev]);
		aligned_free(gold[ndev]);
	}
	return 0;
}


//---------------Initialization of the devices----------------
int init_devs()
{
	int ndev = 0;
	struct esp_device *espdevs;
	// Search for the device
	printf("Scanning device tree... \n");
    for(int i = 0; i<N_ACC_TYPES; i++)
	//for(int i = N_ACC_TILES - 1; i>= 0; i--)
	{
		//For every loop, search for a different accelerator type
		int ndev_local = 0;
		if (i==0)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_ADPCM, DEV_NAME_ADPCM);
			if (ndev_local == 0)
				printf("adpcm not found\n");
		}
        else if(i == 1)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_AES, DEV_NAME_AES);
			if (ndev_local == 0)
				printf("aes not found\n");
		}
		 else if(i == 2)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_BLOWFISH, DEV_NAME_BLOWFISH);
			if (ndev_local == 0)
				printf("blowfish not found\n");
		}
		 else if(i == 3)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFADD, DEV_NAME_DFADD);
			if (ndev_local == 0)
				printf("dfadd not found\n");
		}
		 else if(i == 4)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFDIV, DEV_NAME_DFDIV);
			if (ndev_local == 0)
				printf("dfdiv not found\n");
		}
		 else if(i == 5)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFMUL, DEV_NAME_DFMUL);
			if (ndev_local == 0)
				printf("dfmul not found\n");
		}
		 else if(i == 6)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFSIN, DEV_NAME_DFSIN);
			if (ndev_local == 0)
				printf("dfsin not found\n");
		}
		 else if(i == 7)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_GSM, DEV_NAME_GSM);
			if (ndev_local == 0)
				printf("gsm not found\n");
		}
		 else if(i == 8)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MIPS, DEV_NAME_MIPS);
			if (ndev_local == 0)
				printf("mips not found\n");
		}
		 else if(i == 9)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MOTION, DEV_NAME_MOTION);
			if (ndev_local == 0)
				printf("motion not found\n");
		}
		 else if(i == 10)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_SHA, DEV_NAME_SHA);
			if (ndev_local == 0)
				printf("sha not found\n");
		}
		for (int n = 0; n < ndev_local; n++) {
            //For each accelerator of a given type, initialize all the variables
			//printf("**************** %s.%d ****************\n", espdevs[n].name, n);

			acc_ptr[ndev] = &espdevs[n];

			printf("\nDEVICE INFO\n\n");
			printf("Vendor: %x\n", acc_ptr[ndev]->vendor);
			printf("ID: %x\n", acc_ptr[ndev]->id);
			printf("Number: %x\n", acc_ptr[ndev]->number);
			printf("IRQ: %x\n", acc_ptr[ndev]->irq);
			printf("Address: %llx\n", acc_ptr[ndev]->addr);
			printf("Compat: %u\n", acc_ptr[ndev]->compat);
			printf("Name: %s\n", acc_ptr[ndev]->name);

			//Collect the sizes of its IO
			//printf("Checkpoint 1\n");
			init_size_all(&in_words_adj[ndev], &out_words_adj[ndev], &in_len[ndev], &out_len[ndev], &in_size[ndev], &out_size[ndev], &out_offset[ndev], &mem_size[ndev], i);


			// Check DMA capabilities
			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) == 0)
			{
				printf("  -> scatter-gather DMA is disabled. Abort.\n");
				continue;
			}

			//printf("Checkpoint 2\n");

			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) < NCHUNK(mem_size[ndev])) {
				printf("  -> Not enough TLB entries available. Abort.\n");
				continue;
			}

			//printf("Checkpoint 3\n");

			// Allocate memory
			gold[ndev] = aligned_malloc(out_size[ndev]);
			mem[ndev] = aligned_malloc(mem_size[ndev]);
			//printf("out_size = %d, mem_size=%d\n", out_size[ndev], mem_size[ndev]);
			//printf("  memory buffer base-address = %p\n", mem[ndev]);

			// Alocate and populate page table
			ptable[ndev] = aligned_malloc(NCHUNK(mem_size[ndev]) * sizeof(unsigned *));
			for (int j = 0; j < NCHUNK(mem_size[ndev]); j++)
				ptable[ndev][j] = (unsigned *) &mem[ndev][j * (CHUNK_SIZE / sizeof_token[i])];

			//printf("  ptable = %p\n", ptable[ndev]);
			//printf("  nchunk = %lu\n", NCHUNK(mem_size[ndev]));

			config_cache(ndev, i);

			ndev += 1;
		}
	}
}



//---------------Cache configuration functions----------------
void config_cache(int ndev, int acc_type)
{
	unsigned coherence;
	/* TODO: Restore full test once ESP caches are integrated */
	coherence = ACC_COH_NONE;
	printf("  --------------------\n");
	printf("  Generate input for acc %d of type %d...\n", ndev, acc_type);
	init_buf_all(mem[ndev], gold[ndev], in_words_adj[ndev], acc_type);
    printf("Checkpoint1 - overcame init_buf_all\n");
	// Pass common configuration parameters

	iowrite32(acc_ptr[ndev], SELECT_REG, ioread32(acc_ptr[ndev], DEVID_REG));
	iowrite32(acc_ptr[ndev], COHERENCE_REG, coherence);
    printf("Checkpoint2\n");
#ifndef __sparc
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned long long) ptable[ndev]);
#else
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned) ptable[ndev]);
#endif
	iowrite32(acc_ptr[ndev], PT_NCHUNK_REG, NCHUNK(mem_size[ndev]));
	iowrite32(acc_ptr[ndev], PT_SHIFT_REG, CHUNK_SHIFT);
    printf("Checkpoint3\n");
	// Use the following if input and output data are not allocated at the default offsets
	iowrite32(acc_ptr[ndev], SRC_OFFSET_REG, 0x0);
	iowrite32(acc_ptr[ndev], DST_OFFSET_REG, 0x0);
    printf("Checkpoint4\n");
	// Pass accelerator-specific configuration parameters
	/* <<--regs-config-->> */
	config_acc_param(acc_ptr[ndev], acc_type);
    printf("Checkpoint8 - overcame config_acc_param\n");
	// Flush (customize coherence model here)
	esp_flush(coherence);
	printf("Checkpoint9 - overcame esp_flush\n");
}

//------------------Starting Functions
void run_acc(int ndev)
{
	// Start accelerators
	//printf("  Start...\n");
	iowrite32(acc_ptr[ndev], CMD_REG, CMD_MASK_START);
}


//------------------DFS POLICY-------------------------------------
//			window_end = custom_gettime_nano();
//			if(window_end - window_start > TIME_WINDOW*1000)
//			{
//				unsigned long ejected_total = 0, injected_total = 0;
//				unsigned long window_actual_time = window_end - window_start;
//				window_start = window_end;
//
//				if(toggle == 0)
//				{
//					esp_monitor_transit_all(&vals_packets_1);
//
//					for(int tile=0; tile<N_TILES; tile++)
//					{
//						for(int plane=0; plane<6; plane++)
//						{
//							injected_total += vals_packets_1.noc_injects[tile][plane] - vals_packets_0.noc_injects[tile][plane];
//							ejected_total += vals_packets_1.noc_ejects[tile][plane] - vals_packets_0.noc_ejects[tile][plane];
//						}
//					}
//					toggle =1 ;
//				}
//				else if(toggle == 1)
//				{
//					esp_monitor_transit_all(&vals_packets_0);
//
//					for(int tile=0; tile<N_TILES; tile++)
//					{
//						for(int plane=0; plane<6; plane++)
//						{
//							injected_total += vals_packets_0.noc_injects[tile][plane] - vals_packets_1.noc_injects[tile][plane];
//							ejected_total += vals_packets_0.noc_ejects[tile][plane] - vals_packets_1.noc_ejects[tile][plane];
//						}
//					}
//					toggle =0 ;
//				}
//
//				packets_in_NoC = injected_total - ejected_total;
//				packets_data[samples_counter] = packets_in_NoC;
//				frequency_data[samples_counter] = noc_freq;
//				time_data_debug[samples_counter] = window_actual_time;
//				//if(packets_in_NoC > NOC_TH && noc_freq < FREQ_MAX)
//				//{
//				//	noc_freq++;
//				//	*noc_freq_reg = noc_freq;
//				//}
//				//else if(packets_in_NoC < NOC_TL && noc_freq > FREQ_MIN)
//				//{
//				//	noc_freq--;
//				//	*noc_freq_reg = noc_freq;
//				//}
//				samples_counter++;
//			}
//		}

//------------------DFS POLICY-------------------------------------
//			window_end = custom_gettime_nano();
//			if(window_end - window_start > TIME_WINDOW*1000)
//			{
//				backpressure_total = 0;
//				window_actual_time = window_end - window_start;
//				window_start = window_end;
//				esp_monitor_backpressure_all(&vals_backpressure);
//				for(int tile=N_TILES-1; tile>=0; tile--)
//				{
//					for(int plane=0; plane<6; plane++)
//						for(int queue=0; queue<5; queue++)
//						{
//							backpressure_total += vals_backpressure.noc_queue_full[tile][plane][queue];
//						}
//				}
//                backpressure_diff = backpressure_total - backpressure_old;
//				backpressure_old = backpressure_total;
//				packets_data[samples_counter] = backpressure_diff;
//				frequency_data[samples_counter] = noc_freq;
//				time_data_debug[samples_counter] = window_actual_time;
//				if(backpressure_diff > NOC_TH && noc_freq < FREQ_MAX)
//				{
//					noc_freq++;
//					*noc_freq_reg = noc_freq;
//				}
//				else if(backpressure_diff < NOC_TL && noc_freq > FREQ_MIN)
//				{
//					noc_freq--;
//					*noc_freq_reg = noc_freq;
//				}
//				samples_counter++;
//				//printf("Backpressure: total = %d - increase = %d - Elapsed time = ", backpressure_total, backpressure_diff);
//				//print_time_us(window_actual_time);
//				//printf("\n");
//			}
//		}
