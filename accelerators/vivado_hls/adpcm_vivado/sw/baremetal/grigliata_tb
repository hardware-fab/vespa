/* Copyright (c) 2011-2023 Columbia University, System Level Design Group */
/* SPDX-License-Identifier: Apache-2.0 */

#include <stdio.h>
#ifndef __riscv
#include <stdlib.h>
#endif

#include "esp_accelerator.h"
#include "esp_probe.h"
#include "fixed_point.h"

#include "accelerators.h"
#include <monitors.h>

//TEST CONFIGURATIONS
#define N_NOC_FREQ 5 //(10MHz, 30MHz, 50MHz, 75MHz, 100MHz)
#define N_ACC_FREQ 3 //(10MHz, 30MHz, 50MHz)
#define N_TESTS (N_ACC_FREQ*N_ACC_FREQ*N_ACC_FREQ*N_NOC_FREQ)

//---------------------Timer Definitions-----------------------------
#define BASE_ADDRESS 0x60000300
#define TIMER_LO 0xB4
#define TIMER_HI 0xB8
#define DOMAIN_0 ((16 + 0)*4 + 128)
#define DOMAIN_1 ((16 + 1)*4 + 128)
#define DOMAIN_2 ((16 + 2)*4 + 128)
#define DOMAIN_3 ((16 + 3)*4 + 128)
#define DOMAIN_4 ((16 + 4)*4 + 128)

static long unsigned custom_gettime_nano()
{
	volatile unsigned long timer_reg_lo, timer_reg_hi;
	volatile uint32_t * timer_lo_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_LO);
	volatile uint32_t * timer_hi_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_HI);
	timer_reg_lo = *timer_lo_ptr;
	timer_reg_hi = *timer_hi_ptr;
	return (long unsigned) ((*timer_lo_ptr | (long unsigned)(*timer_hi_ptr)<<32)*CLOCK_PERIOD);
}

static void print_time(long unsigned value)
{
	uint32_t nano = value%1000;
	uint32_t micro = (value%1000000)/1000;
	uint32_t milli = (value%1000000000)/1000000;
	uint32_t sec = (value%1000000000000)/1000000000;
	printf("Original Value = %lu : %u s - %u ms - %u us - %u ns", value, sec, milli, micro, nano);
}

static void print_time_us(long unsigned value)
{
	uint32_t decimal = value%1000;
	uint32_t integer = (value)/1000;
	printf("%u,%03u", integer, decimal);
}

static void wait_micro(long unsigned waiting_time)
{
	long unsigned start, end;
	start = custom_gettime_nano();
	end = 0;
	while(end < start + waiting_time*1000)
		end = custom_gettime_nano();
	return;
}

//--------------Global Variables--------------------------
//Accelerators size variables
static unsigned in_words_adj[N_ACC_TILES];
static unsigned out_words_adj[N_ACC_TILES];
static unsigned in_len[N_ACC_TILES];
static unsigned out_len[N_ACC_TILES];
static unsigned in_size[N_ACC_TILES];
static unsigned out_size[N_ACC_TILES];
static unsigned out_offset[N_ACC_TILES];
static unsigned mem_size[N_ACC_TILES];

//Devices info
struct esp_device *acc_ptr[N_ACC_TILES];

//Accelerators I/O
unsigned **ptable[N_ACC_TILES];
uint8_t *mem[N_ACC_TILES];
uint8_t *gold[N_ACC_TILES];
unsigned errors = 0;

//Execution results
unsigned samples_counter = 0;
//unsigned packets_data[N_SAMPLES];
//unsigned packets_data_2[N_SAMPLES];
//uint8_t noc_frequency_data[N_SAMPLES];
//uint8_t acc_frequency_data[N_SAMPLES];
//uint8_t tg_frequency_data[N_SAMPLES];
//unsigned time_data_debug[N_SAMPLES];

//Available frequencies
uint8_t available_noc_freq[N_NOC_FREQ] = {1, 5, 9, 14, 19};
uint8_t available_acc_freq[N_ACC_FREQ] = {1, 5, 9};

//Accelerators batch sizes
unsigned acc_batch_sizes[N_ACC_TILES];


//--------------Functions Declaration------------------
int init_devs();
void config_cache();
void run_acc();

int main(int argc, char * argv[])
{
	printf("------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------START-----------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n---------------------------------------------------------------------------------------------\n\n\n");

	//-----------------------------------Local variables------------------------------------

	//Accelerators execution
	int ready[N_ACC_TILES] = {0};
	int counter[N_ACC_TILES] = {0};
	unsigned done[N_ACC_TILES] = {0};
	int ready_all = 0;

	//Monitor variables
	unsigned backpressure_old = 0;
	esp_monitor_vals_t vals_backpressure;
	esp_monitor_vals_t vals_packets_0, vals_packets_1;
	unsigned long packets_in_NoC = 0;
	unsigned long packets_to_mem = 0, packets_from_mem = 0;
	unsigned long backpressure_total;
	int backpressure_diff;
    int toggle = 0;

	//Time variables
	double start_time, time_elapsed = 0;
	double time_acc[N_ACC_TILES] = {0};
	double window_start, window_end;
	unsigned long window_actual_time;
    static double total_time_bench[6];
	int total_counter_bench[6];

	//Frequency data
	unsigned noc_freq = 1;
	volatile uint32_t * noc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_0);
	volatile uint32_t * cpu_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_1);
    volatile uint32_t * acc1_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_2);
	volatile uint32_t * acc2_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_3);
	volatile uint32_t * acc3_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_4);
	uint8_t noc_freq_int = 0;
	uint8_t cpu_freq_int = 0;
	uint8_t acc_freq_int[N_ACC_TILES] = {0};

	int dfadd_active = 0;

	//*cpu_freq_reg = FREQ_START;   //9 = 50MHz
	//*noc_freq_reg = noc_freq;
	//*domain2_freq_reg = FREQ_START;   //9 = 50MHz
	//*domain3_freq_reg = FREQ_START;   //9 = 50MHz

	init_devs();
	printf("The devices have been initialized\n");
    cpu_freq_int = 9;
	*cpu_freq_reg = cpu_freq_int;

	window_start = custom_gettime_nano();
	for (int m=0; m<N_TESTS; m++)
	{
		printf("Checkpoint 1\n");
		//Initialize run control variables
		//printf("Start Execution!!!\n");
		ready_all = 0;
		time_elapsed = 0;
		start_time = custom_gettime_nano();
		printf("Checkpoint 2\n");
		acc_freq_int[0] = available_acc_freq[m%N_ACC_FREQ];
		acc_freq_int[1] = available_acc_freq[(m/N_ACC_FREQ)%N_ACC_FREQ];
		acc_freq_int[2] = available_acc_freq[(m/(N_ACC_FREQ*N_ACC_FREQ))%N_ACC_FREQ];
		noc_freq_int = available_noc_freq[(m/(N_ACC_FREQ*N_ACC_FREQ*N_ACC_FREQ))%N_NOC_FREQ];
		printf("Freq of acc 0 = %d\n", acc_freq_int[0]);
		printf("Freq of acc 1 = %d\n", acc_freq_int[1]);
		printf("Freq of acc 2 = %d\n", acc_freq_int[2]);
		printf("Freq of noc = %d\n", noc_freq_int);
		printf("Checkpoint 3\n");
		*noc_freq_reg = noc_freq_int;
		*acc1_freq_reg = acc_freq_int[0];  //Questa riga rompe qualcosa
		*acc2_freq_reg = acc_freq_int[1];
		*acc3_freq_reg = acc_freq_int[2];
		printf("Checkpoint 4\n");
		for(int ndev=0; ndev<N_ACC_TILES; ndev++)
		{
			run_acc(ndev);		//Questa riga rompe qualcosa
			ready[ndev] = 0;
		}
		printf("Checkpoint 5\n");
		while(!(ready_all && time_elapsed))
		{
			//-------------------ACCELERATORS EXECUTION----------------------------
			ready_all = 1;
			for(int ndev=0; ndev<N_ACC_TILES; ndev++)
			{
				printf("Checkpoint 6\n");
				//printf("Accelerator %d: done = %d, ready = %d\n", ndev, done[ndev], ready[ndev]);
				done[ndev] = ioread32(acc_ptr[ndev], STATUS_REG);
				done[ndev] &= STATUS_MASK_DONE;
				if(!ready[ndev] && done[ndev])
				{
					done[ndev] = 0;
					iowrite32(acc_ptr[ndev], CMD_REG, 0x0);
					run_acc(ndev);
					counter[ndev]++;
					if(time_elapsed)
					{
						time_acc[ndev] = custom_gettime_nano() - start_time;
						ready[ndev] = 1;
					}
				}
				if(!ready[ndev])
					ready_all = 0;
			}

			if(custom_gettime_nano() - start_time > ((unsigned long)MAX_TEST_TIME*1000000000) && !time_elapsed)
				time_elapsed = 1;

		}

		printf("\nTempo di esecuzione: ");
		uint8_t y_pos[N_ACC_TILES];
		for(int iter = 0; iter<N_ACC_TILES; iter++)
		{
			y_pos[iter] = acc_ptr[iter]->addr & 0x00000F00;
		    printf(" - %d", y_pos);
		}
		printf(" - %d", noc_freq_int);
		for(int iter = 0; iter<N_ACC_TILES; iter++)
		{
		    printf(" - %d", acc_freq_int[y_pos[iter]]);
		}
		for(int iter = 0; iter<N_ACC_TILES; iter++)
		{
			printf(" - ");
		    print_time_us(time_acc[iter]/(counter[iter]*acc_batch_sizes[iter]));
		}
		printf("\n");
	}
    printf("Execution Completed\n");
	//for(int iter=1; iter<2; iter++)
	//{
	//	int errors = print_results(iter, gold[iter], &mem[iter][out_offset[iter]], out_words_adj[iter], mem[iter]);
	//}
	//for(int k=0; k<100; k++)
	//{
	//	printf("dfsin_result[%d] = %016llx\n", k, *((uint64_t *)&mem[6][800 + k*8]));
	//}
	///* Validation */
	//errors = validate_buf(&mem[out_offset], gold);

	//for(int iter = 0; iter<N_ACC_TILES; iter++)
	//{
	//	printf("\nExecution time of the accelerator %d is: ", iter);
	//    print_time_us(time_acc[iter]/counter[iter]);
	//	printf("\n");
	//}
	//for(int iter = 0; iter<6; iter++)
	//{
	//	//printf("\nExecution time of the accelerator %d is: ", iter);
	//    print_time_us(total_time_bench[iter]/(total_counter_bench[iter]*BENCH_N));
	//	printf("\n");
	//}
	for(int ndev=0; ndev = N_ACC_TILES; ndev++)
	{
		aligned_free(ptable[ndev]);
		aligned_free(mem[ndev]);
		aligned_free(gold[ndev]);
	}
	return 0;
}


//---------------Initialization of the devices----------------
int init_devs()
{
	int ndev = 0;
	struct esp_device *espdevs;
	// Search for the device
	printf("Scanning device tree... \n");
    for(int i = 0; i<N_ACC_TYPES; i++)
	//for(int i = N_ACC_TYPES - 1; i>= 0; i--)
	{
		//For every loop, search for a different accelerator type
		int ndev_local = 0;
		if (i==0)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_ADPCM, DEV_NAME_ADPCM);
			if (ndev_local == 0)
				printf("adpcm not found\n");
		}
        else if(i == 1)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_AES, DEV_NAME_AES);
			if (ndev_local == 0)
				printf("aes not found\n");
		}
		 else if(i == 2)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_BLOWFISH, DEV_NAME_BLOWFISH);
			if (ndev_local == 0)
				printf("blowfish not found\n");
		}
		 else if(i == 3)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFADD, DEV_NAME_DFADD);
			if (ndev_local == 0)
				printf("dfadd not found\n");
		}
		 else if(i == 4)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFDIV, DEV_NAME_DFDIV);
			if (ndev_local == 0)
				printf("dfdiv not found\n");
		}
		 else if(i == 5)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFMUL, DEV_NAME_DFMUL);
			if (ndev_local == 0)
				printf("dfmul not found\n");
		}
		 else if(i == 6)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFSIN, DEV_NAME_DFSIN);
			if (ndev_local == 0)
				printf("dfsin not found\n");
		}
		 else if(i == 7)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_GSM, DEV_NAME_GSM);
			if (ndev_local == 0)
				printf("gsm not found\n");
		}
		 else if(i == 8)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MIPS, DEV_NAME_MIPS);
			if (ndev_local == 0)
				printf("mips not found\n");
		}
		 else if(i == 9)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MOTION, DEV_NAME_MOTION);
			if (ndev_local == 0)
				printf("motion not found\n");
		}
		 else if(i == 10)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_SHA, DEV_NAME_SHA);
			if (ndev_local == 0)
				printf("sha not found\n");
		}
		for (int n = 0; n < ndev_local; n++) {
            //For each accelerator of a given type, initialize all the variables
			//printf("**************** %s.%d ****************\n", espdevs[n].name, n);

			acc_ptr[ndev] = &espdevs[n];

			printf("\nDEVICE INFO\n\n");
			printf("Vendor: %x\n", acc_ptr[ndev]->vendor);
			printf("ID: %x\n", acc_ptr[ndev]->id);
			printf("Number: %x\n", acc_ptr[ndev]->number);
			printf("IRQ: %x\n", acc_ptr[ndev]->irq);
			printf("Address: %llx\n", acc_ptr[ndev]->addr);
			printf("Compat: %u\n", acc_ptr[ndev]->compat);
			printf("Name: %s\n", acc_ptr[ndev]->name);

			printf("PT NCHUNK MAX REG: %d\n", ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG));

			//Collect the sizes of its IO
			//printf("Checkpoint 1\n");
			init_size_all(&in_words_adj[ndev], &out_words_adj[ndev], &in_len[ndev], &out_len[ndev], &in_size[ndev], &out_size[ndev], &out_offset[ndev], &mem_size[ndev], i);
			get_batch_size(&acc_batch_sizes[ndev], i);

			// Check DMA capabilities
			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) == 0)
			{
				printf("  -> scatter-gather DMA is disabled. Abort.\n");
				//continue;
			}

			//printf("Checkpoint 2\n");

			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) < NCHUNK(mem_size[ndev])) {
				printf("  -> Not enough TLB entries available. Abort.\n");
				//continue;
			}

			//printf("Checkpoint 3\n");

			// Allocate memory
			gold[ndev] = aligned_malloc(out_size[ndev]);
			mem[ndev] = aligned_malloc(mem_size[ndev]);
			//printf("out_size = %d, mem_size=%d\n", out_size[ndev], mem_size[ndev]);
			//printf("  memory buffer base-address = %p\n", mem[ndev]);

			// Alocate and populate page table
			ptable[ndev] = aligned_malloc(NCHUNK(mem_size[ndev]) * sizeof(unsigned *));
			for (int j = 0; j < NCHUNK(mem_size[ndev]); j++)
				ptable[ndev][j] = (unsigned *) &mem[ndev][j * (CHUNK_SIZE / sizeof_token[i])];

			//printf("  ptable = %p\n", ptable[ndev]);
			//printf("  nchunk = %lu\n", NCHUNK(mem_size[ndev]));

			config_cache(ndev, i);

			ndev += 1;
		}
	}
}



//---------------Cache configuration functions----------------
void config_cache(int ndev, int acc_type)
{
	unsigned coherence;
	/* TODO: Restore full test once ESP caches are integrated */
	coherence = ACC_COH_NONE;
	printf("  --------------------\n");
	printf("  Generate input for acc %d of type %d...\n", ndev, acc_type);
	init_buf_all(mem[ndev], gold[ndev], in_words_adj[ndev], acc_type);
    //printf("Checkpoint1 - overcame init_buf_all\n");
	// Pass common configuration parameters

	iowrite32(acc_ptr[ndev], SELECT_REG, ioread32(acc_ptr[ndev], DEVID_REG));
	iowrite32(acc_ptr[ndev], COHERENCE_REG, coherence);
    //printf("Checkpoint2\n");
#ifndef __sparc
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned long long) ptable[ndev]);
#else
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned) ptable[ndev]);
#endif
	iowrite32(acc_ptr[ndev], PT_NCHUNK_REG, NCHUNK(mem_size[ndev]));
	iowrite32(acc_ptr[ndev], PT_SHIFT_REG, CHUNK_SHIFT);
    //printf("Checkpoint3\n");
	// Use the following if input and output data are not allocated at the default offsets
	iowrite32(acc_ptr[ndev], SRC_OFFSET_REG, 0x0);
	iowrite32(acc_ptr[ndev], DST_OFFSET_REG, 0x0);
    //printf("Checkpoint4\n");
	// Pass accelerator-specific configuration parameters
	/* <<--regs-config-->> */
	config_acc_param(acc_ptr[ndev], acc_type);
    //printf("Checkpoint8 - overcame config_acc_param\n");
	// Flush (customize coherence model here)
	esp_flush(coherence);
	//printf("Checkpoint9 - overcame esp_flush\n");
}

//------------------Starting Functions
void run_acc(int ndev)
{
	// Start accelerators
	//printf("  Start...\n");
	iowrite32(acc_ptr[ndev], CMD_REG, CMD_MASK_START);
}
